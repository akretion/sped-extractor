import logging
from collections import defaultdict
from collections import OrderedDict
from itertools import groupby
from pathlib import Path
from typing import List

import click
from black import FileMode
from black import format_str
from xsdata.codegen.models import Attr
from xsdata.codegen.models import AttrType
from xsdata.codegen.models import Class
from xsdata.codegen.models import Restrictions
from xsdata.formats.dataclass.filters import Filters
from xsdata.models.config import GeneratorConfig
from xsdata.models.config import GeneratorSubstitution
from xsdata.models.config import ObjectType
from xsdata_odoo.generator import GeneratorResult
from xsdata_odoo.generator import OdooFilters
from xsdata_odoo.generator import OdooGenerator
from xsdata_odoo.wrap_text import extract_string_and_help

from .build_csv import _is_reg_row
from .build_csv import clean_row
from .build_csv import get_blocks
from .build_csv import get_fields
from .build_csv import get_raw_rows
from .build_csv import get_registers
from .constants import MODULES
from .constants import MOST_RECENT_YEAR
from .constants import OLDEST_YEAR
from .constants import SPECS_PATH

logger = logging.getLogger(__name__)
logger.addHandler(logging.StreamHandler())
logger.setLevel(logging.INFO)

HEADER = """# Copyright 2022 Akretion - Raphaël Valyi <raphael.valyi@akretion.com>
# License LGPL-3.0 or later (https://www.gnu.org/licenses/lgpl-3.0.en.html).
# Generated by https://github.com/akretion/xsdata-odoo
"""

IMPORTS = """import textwrap
from odoo import fields, models
"""


# NOTE doc estrutura https://www.youtube.com/watch?v=dhdo9lXwVZg
# Reinf https://www.youtube.com/watch?v=K4b3XqkYyJk


# TODO ECD I550 e I555: campos RZ_CONT e RZ_CONT_TOT são parametrizaveis, ver manual e demo!

def collect_register_children(registers):
    """read the registers hierarchy."""
    for register_info in registers:
        if register_info["level"] > 1:
            collect_children = False
            children_o2m = []
            children_m2o = []
            level = register_info["level"]
            for r in registers:
                if r["code"] == register_info["code"]:
                    collect_children = True
                    continue
                if collect_children:
                    if r["level"] == level + 1:
                        if r["card"].strip() == "1:1" or r["card"].strip() == "1;1":
                            children_m2o.append(r)
                        else:
                            children_o2m.append(r)
                            r["parent"] = register_info
                    elif r["level"] <= level:
                        break
            register_info["children_o2m"] = children_o2m
            register_info["children_m2o"] = children_m2o


def get_structure(mod, registers):
    structure = f"STRUCTURE SPED {mod.upper()}"
    for reg in registers:
        short_desc, left = extract_string_and_help(
            mod, reg["code"], reg["desc"], set(), 50
        )
        reg["short_desc"] = short_desc

        if reg["level"] == 0:
            continue
        if reg["level"] == 1:
            if "990" not in reg["code"] and "099" not in reg["code"]:  # not enceramento
                structure += "\n\n<BLOCO " + reg["code"][0] + ">"
            continue
        if reg["level"] == 2:
            structure += "\n"
            desc = reg["short_desc"].upper()
        elif reg["level"] == 3:
            desc = reg["short_desc"]
        else:
            desc = ""
        if desc == reg["code"]:
            desc = reg["desc"][:40] + "..."
        if reg.get("parent"):
            structure += (
                "\n" + "  " * (reg["level"] - 1) + "\u2261 " + reg["code"] + " " + desc
            )
        else:
            structure += (
                "\n" + "  " * (reg["level"] - 1) + "- " + reg["code"] + " " + desc
            )
    return structure


class SpedFilters(OdooFilters):
    def registry_name(self, name: str) -> str:
        name = self.class_name(name)
        return f"{self.schema}.{self.version}.{name[-4:].lower()}"

    def class_properties(
        self,
        obj: Class,
        parents: List[Class],
    ) -> str:
        register = list(filter(lambda x: x["code"] == obj.name[-4:], self.registers))[0]
        return f"_sped_level = {register['level']}"

    def extract_field_attributes(self, parents: List[Class], attr: Attr):
        obj = parents[-1]
        kwargs = OrderedDict()
        if not hasattr(obj, "unique_labels"):
            obj.unique_labels = set()  # will avoid repeating field labels
        string, help_attr = extract_string_and_help(
            obj.name, attr.name, attr.help, obj.unique_labels
        )
        kwargs["string"] = string

        metadata = self.field_metadata(attr, {}, [p.name for p in parents])
        if metadata.get("required") or (not attr.is_list and not attr.is_optional):
            # we choose not to put required=True (required in database) to avoid
            # messing with existing Odoo modules.
            if "sped" in self.schema:
                kwargs["required"] = True
            else:
                kwargs["xsd_required"] = True

        if "sped" in self.schema and attr.default:  # hack to pass TDec_
            xsd_type = attr.default
        else:
            xsd_type = self.simple_type_from_xsd(obj, attr)
        if xsd_type and xsd_type not in [
            "xsd:string",
            "xsd:date",
        ]:  # (not in trivial types)
            kwargs["xsd_type"] = xsd_type

        if help_attr:
            kwargs["help"] = help_attr

        return kwargs


@click.option(
    "--year",
    default=MOST_RECENT_YEAR,
    show_default=True,
    type=click.IntRange(OLDEST_YEAR, MOST_RECENT_YEAR),
    help="Operate on a specific year's folder, "
    f"can be between {OLDEST_YEAR} and {MOST_RECENT_YEAR}",
)
@click.command()
def main(year):
    """Generate Odoo models."""

    config = GeneratorConfig()

    # the SPED spec has a couple of bad field names we cannot use in Python/Odoo:
    # (we know them by running flake8/black on the the generated files before fixing them)
    config.substitutions.substitution += [
        GeneratorSubstitution(
            type=ObjectType.FIELD, search="NIF/CNPJ", replace="NIF_CNPJ"
        ),  # ecf X357
        GeneratorSubstitution(
            type=ObjectType.FIELD, search="TP_CT-e", replace="TP_CT_e"
        ),  # efd_icms_ipi, efd_pis_cofins
        GeneratorSubstitution(
            type=ObjectType.FIELD, search="IND_E-COM_TI", replace="IND_E_COM_TI"
        ),  # ecf
    ]
    config.conventions.field_name.safe_prefix = (
        "NO_PREFIX_NO_SAFE_NAME"  # no field prefix
    )
    generator = OdooGenerator(config)

    generator.filters = SpedFilters(
        config,
        [],
        [],
        defaultdict(list),
    )
    generator.filters.register(generator.env)
    generator.filters.python_inherit_model = "models.Model"
    generator.filters.inherit_model = "l10n_br_sped.mixin"

    security_csv = '"id","name","model_id:id","group_id:id","perm_read","perm_write","perm_create","perm_unlink"\n'
    for mod in MODULES:
        print("********************* MOD", mod)
        schema = f"l10n_br_sped.{mod}"
        generator.filters.schema = schema
        version = "1"  # FIXME
        generator.filters.version = version
        mod_fields = get_fields(mod, year)

        views_xml = '<?xml version="1.0" encoding="UTF-8"?>\n<odoo>'
        views_xml += ('\n    <menuitem name="%s"'
            ' parent="menu_root" id="%s" sequence="2" />'
        ) % (mod.replace("_", " ").upper(), mod)
        last_bloco = None

        classes = []
        registers = list(
            sorted(
                filter(
                    lambda x: x["code"][0] != "C" or mod not in ("ecd", "ecf"),
                    get_registers(mod, year),
                ),
                key=lambda x: x["code"][0] == "0"
                and "a" + x["code"]
                or x["code"][0] == "9"
                and "d" + x["code"]
                or x["code"][0] == "1"
                and "c" + x["code"]
                or "b" + x["code"],
            )
        )
        collect_register_children(registers)
        generator.filters.registers = registers

        for register in registers:
            short_desc, left = extract_string_and_help(
                mod, register["code"], register["desc"], set(), 50
            )
            register["short_desc"] = short_desc

            bloco_char = register["code"][0]
            if bloco_char != last_bloco:
                views_xml += ('\n\n\n    <menuitem name="BLOCO %s"'
                            ' parent="%s" id="%s_%s"/>'
                            ) % (bloco_char,
                                mod,
                                mod,
                                bloco_char.lower())
            last_bloco = bloco_char

            if register["level"] == 2:
                action_name = register["short_desc"]
                action = """\n
    <record id='%s_%s_action' model='ir.actions.act_window'>
        <field name="name">%s</field>
        <field name="res_model">l10n_br_sped.%s.%s.%s</field>
        <field name="view_mode">tree,form</field>
    </record>""" % (mod,
                        register["code"].lower(),
                        action_name,
                        mod,
                        version,
                        register["code"].lower())
                views_xml += action

                views_xml += ('\n    <menuitem action="%s_%s_action"'
                            ' parent="%s_%s" id="%s_%s"/>') % (
                                mod,
                                register["code"].lower(),
                                mod,
                                bloco_char.lower(),
                                mod,
                                register["code"].lower(),
                            )


            if register["level"] in (0, 1):  # Blocks and their start/end registers
                continue

            name = f"Registro{register['code']}"
            attrs = []
            for field in list(filter(lambda x: x["register"] == register["code"], mod_fields)): #list(group):
                tdec = None
                if field["code"] in (
                    "REG",
                    "1REG",
                ):  # no need for DB field for fixed field
                    continue

                # TODO FIXME should be fixed in field extraction upfront!
                if field["code"][-1] in ("*", "_", ";"):
                    field["code"] = field["code"][:-1]

                if not field.get("type"):
                    print("ERROR !!!!!!!!!!!!", field)
                    field["type"] = "string"
                if field["code"].startswith("DT_"):
                    types = [
                        AttrType(
                            qname="{http://www.w3.org/2001/XMLSchema}date", native=True
                        )
                    ]
                elif (
                    field["type"] == "int"
                    or field["type"] == "float"
                    and int(field["decimal"]) == 0
                ):
                    types = [
                        AttrType(
                            qname="{http://www.w3.org/2001/XMLSchema}integer",
                            native=True,
                        )
                    ]
                elif field["type"] == "float":
                    digits = int(field["decimal"])
                    if digits < 10:
                        tdec = f"TDec_160{digits}"
                    else:
                        tdec = f"TDec_16{digits}"
                    types = [
                        AttrType(
                            qname="{http://www.w3.org/2001/XMLSchema}float", native=True
                        )
                    ]
                else:
                    types = [
                        AttrType(
                            qname="{http://www.w3.org/2001/XMLSchema}string",
                            native=True,
                        )
                    ]
                # TODO diff entrada/saida e O / OC (Obrigatorio Condicional); see ICMS C170
                restrictions = Restrictions(
                    min_occurs=field.get("required")
                    and 1
                    or 0  # TODO if required 'OC' -> no
                )
                attr = Attr(
                    tag=field["code"],
                    name=field["code"],
                    types=types,
                    restrictions=restrictions,
                    help=field["desc"],
                    index=field["index"],
                    default=tdec,
                )
                attrs.append(attr)
                # TODO add date_field and company_id if level == 1, or via mixin?

            for child in register["children_m2o"]:
                child_qname = "Registro{}".format(child["code"])
                types = [AttrType(qname=child_qname, native=False)]
                m2o_field_name = "reg_{}_id".format(child["code"])
                restrictions = Restrictions(
                    min_occurs=0  # TODO sure?
                )
                attr = Attr(
                    tag=m2o_field_name,
                    name=m2o_field_name,
                    types=types,
                    restrictions=restrictions,
                    help=child["code"] + ": " + child["desc"],
                )
                attrs.append(attr)

            if register.get("parent"):
                parent = register["parent"]
                parent_qname = "Registro{}".format(parent["code"])
                types = [AttrType(qname=parent_qname, native=False)]
                m2o_field_name = "reg_{}_ids_{}_id".format(
                    register["code"], parent_qname
                )
                attr = Attr(
                    tag=m2o_field_name,
                    name=m2o_field_name,
                    types=types,
                    help=parent["desc"],
                )
                attrs.append(attr)

            for child in register["children_o2m"]:
                child_qname = "Registro{}".format(child["code"])
                types = [AttrType(qname=child_qname, native=False)]
                restrictions = Restrictions(
                    max_occurs=999999
                )  # TODO make it work. It uses metadata in generate.py and fail

                o2m_field_name = "reg_{}_ids".format(child["code"])
                # TODO find a way to pass string=child["code"]
                attr = Attr(
                    tag=o2m_field_name,
                    name=o2m_field_name,
                    types=types,
                    restrictions=restrictions,
                    help=child["code"] + ": " + child["desc"],
                )
                attrs.append(attr)

            # TODO patch ECD Registro0035
            k = Class(
                qname=name,
                tag=name,
                location="TODO",
                attrs=attrs,
                help=register["desc"],
                module=mod,
            )
            classes.append(k)
            generator.filters.all_complex_types.append(k)
            security_csv += f"access_{mod}_{register['code'].lower()},{mod}.{register['code'].lower()},model_l10n_br_sped_{mod}_{version}_{register['code'].lower()},base.group_user,1,1,1,1\n"

        structure = get_structure(mod, registers)
        source = (
            HEADER
            + f'\n"""\n{structure}\n"""\n\n'
            + IMPORTS
            + "\n"
            + generator.render_classes(classes, None)
        )
        try:
            source = format_str(source, mode=FileMode())
        except Exception as e:
            print(e)

        base_path = str(SPECS_PATH) + f"/{year}/"
#        base_path = "/home/rvalyi/DEV/analogica/odoo/local-src/"  # FIXME
        path = Path(f"/{base_path}/l10n_br_sped/models/sped_{mod}.py")
        print("written file", path)
        path.write_text(source, encoding="utf-8")

        path = Path(f"/{base_path}/l10n_br_sped/views/sped_{mod}.xml")
        path.write_text(views_xml + "\n</odoo>", encoding="utf-8")


    path = Path(f"/{base_path}/l10n_br_sped/security/ir.model.access.csv")
    path.write_text(security_csv, encoding="utf-8")



if __name__ == "__main__":
    main()
