import logging
from collections import defaultdict
from collections import OrderedDict
from itertools import groupby
from pathlib import Path
from typing import List

import click
from black import FileMode
from black import format_str
from xsdata.codegen.models import Attr
from xsdata.codegen.models import AttrType
from xsdata.codegen.models import Class
from xsdata.codegen.models import Restrictions
from xsdata.formats.dataclass.filters import Filters
from xsdata.models.config import GeneratorConfig
from xsdata.models.config import GeneratorSubstitution
from xsdata.models.config import ObjectType
from xsdata_odoo.generator import GeneratorResult
from xsdata_odoo.generator import OdooFilters
from xsdata_odoo.generator import OdooGenerator
from xsdata_odoo.wrap_text import extract_string_and_help

from .build_csv import _is_reg_row
from .build_csv import clean_row
from .build_csv import get_blocks
from .build_csv import get_fields
from .build_csv import get_raw_rows
from .build_csv import get_registers
from .constants import MODULES
from .constants import MOST_RECENT_YEAR
from .constants import OLDEST_YEAR
from .constants import SPECS_PATH

logger = logging.getLogger(__name__)
logger.addHandler(logging.StreamHandler())
logger.setLevel(logging.INFO)

HEADER = """# Copyright 2022 Akretion - RaphaÃ«l Valyi <raphael.valyi@akretion.com>
# License LGPL-3.0 or later (https://www.gnu.org/licenses/lgpl-3.0.en.html).
# Generated by https://github.com/akretion/xsdata-odoo
"""

IMPORTS = """import textwrap
from odoo import fields, models
"""


# NOTE doc estrutura https://www.youtube.com/watch?v=dhdo9lXwVZg
# Reinf https://www.youtube.com/watch?v=K4b3XqkYyJk


def collect_register_children(registers):
    """reads the registers hierarchy."""
    for register_info in registers:
        if register_info["level"] > 1:
            collect_children = False
            children_o2m = []
            children_m2o = []
            level = register_info["level"]
            for r in registers:
                if r["code"] == register_info["code"]:
                    collect_children = True
                    continue
                if collect_children:
                    if r["level"] == level + 1:
                        if r["card"].strip() == "1:1" or r["card"].strip() == "1;1":
                            children_m2o.append(r)
                        else:
                            children_o2m.append(r)
                            r["parent"] = register_info
                    elif r["level"] <= level:
                        break
            register_info["children_o2m"] = children_o2m
            register_info["children_m2o"] = children_m2o


def get_structure(mod, registers):
    structure = f"STRUCTURE SPED {mod.upper()}"
    for reg in registers:
        if reg["level"] == 0:
            continue
        if reg["level"] == 1:
            if "990" not in reg["code"] and "099" not in reg["code"]:  # not enceramento
                structure += "\n\n<BLOCO " + reg["code"][0] + ">"
            continue
        if reg["level"] == 2:
            structure += "\n"
            desc, left = extract_string_and_help(
                mod, reg["code"], reg["desc"].upper(), set()
            )
        elif reg["level"] == 3:
            desc, left = extract_string_and_help(
                mod, reg["code"], reg["desc"].lower(), set()
            )
        else:
            desc = ""
        if desc == reg["code"]:
            desc = reg["desc"][:40] + "..."
        if reg.get("parent"):
            structure += (
                "\n" + "  " * (reg["level"] - 1) + "\u2261 " + reg["code"] + " " + desc
            )
        else:
            structure += (
                "\n" + "  " * (reg["level"] - 1) + "- " + reg["code"] + " " + desc
            )
    return structure


class SpedFilters(OdooFilters):
    def registry_name(self, name: str) -> str:
        name = self.class_name(name)
        return f"{self.schema}.{self.version}.{name[-4:]}"

    def extract_field_attributes(self, parents: List[Class], attr: Attr):
        obj = parents[-1]
        kwargs = OrderedDict()
        if not hasattr(obj, "unique_labels"):
            obj.unique_labels = set()  # will avoid repeating field labels
        string, help_attr = extract_string_and_help(
            obj.name, attr.name, attr.help, obj.unique_labels
        )
        kwargs["string"] = string

        metadata = self.field_metadata(attr, {}, [p.name for p in parents])
        if metadata.get("required") or (not attr.is_list and not attr.is_optional):
            # we choose not to put required=True (required in database) to avoid
            # messing with existing Odoo modules.
            if "sped" in self.schema:
                kwargs["required"] = True
            else:
                kwargs["xsd_required"] = True

        if "sped" in self.schema and attr.default:  # hack to pass TDec_
            xsd_type = attr.default
        else:
            xsd_type = self.simple_type_from_xsd(obj, attr)
        if xsd_type and xsd_type not in [
            "xsd:string",
            "xsd:date",
        ]:  # (not in trivial types)
            kwargs["xsd_type"] = xsd_type

        if help_attr and help_attr != string:
            kwargs["help"] = help_attr

        return kwargs


@click.option(
    "--year",
    default=MOST_RECENT_YEAR,
    show_default=True,
    type=click.IntRange(OLDEST_YEAR, MOST_RECENT_YEAR),
    help="Operate on a specific year's folder, "
    f"can be between {OLDEST_YEAR} and {MOST_RECENT_YEAR}",
)
@click.command()
def main(year):
    """Generate Odoo models."""

    config = GeneratorConfig()

    # the SPED spec has a couple of bad field names we cannot use in Python/Odoo:
    # (we know them by running flake8/black on the the generated files before fixing them)
    config.substitutions.substitution += [
        GeneratorSubstitution(
            type=ObjectType.FIELD, search="NIF/CNPJ", replace="NIF_CNPJ"
        ),  # ecf X357
        GeneratorSubstitution(
            type=ObjectType.FIELD, search="TP_CT-e", replace="TP_CT_e"
        ),  # efd_icms_ipi, efd_pis_cofins
    ]
    config.conventions.field_name.safe_prefix = (
        "NO_PREFIX_NO_SAFE_NAME"  # no field prefix
    )
    generator = OdooGenerator(config)

    generator.filters = SpedFilters(
        config,
        [],
        [],
        defaultdict(list),
    )
    generator.filters.register(generator.env)
    generator.filters.python_inherit_model = "models.Model"
    generator.filters.inherit_model = "l10n_br_sped.mixin"

    for mod in MODULES:
        print("********************* MOD", mod)
        schema = f"l10n_br_sped.{mod}"
        generator.filters.schema = schema
        version = "1"  # FIXME
        generator.filters.version = version
        classes = []
        registers = list(
            sorted(
                filter(
                    lambda x: x["code"][0] != "C" or mod not in ("ecd", "ecf"),
                    get_registers(mod, year),
                ),
                key=lambda x: x["code"][0] == "0"
                and "a" + x["code"]
                or x["code"][0] == "9"
                and "d" + x["code"]
                or x["code"][0] == "1"
                and "c" + x["code"]
                or "b" + x["code"],
            )
        )
        collect_register_children(registers)

        fields = get_fields(mod, year)
        field_iterator = groupby(fields, lambda x: x["register"])
        for reg_code, group in field_iterator:
            matching_registers = list(
                filter(lambda x: x["code"] == reg_code, registers)
            )
            if not matching_registers:  # non data register
                continue
            register = matching_registers[0]
            if register["level"] in (0, 1):  # Blocks and their start/end registers
                continue
            #            if register["code"][0] in ["0", "9"]:  # TODO sure? These aren't transaction but having them in a table might be handy
            #                continue

            name = f"Registro{reg_code}"
            attrs = []
            for field in list(group):
                tdec = None
                if field["code"] in (
                    "REG",
                    "1REG",
                ):  # no need for DB field for fixed field
                    continue

                # TODO FIXME should be fixed in field extraction upfront!
                if field["code"][-1] in ("*", "_", ";"):
                    field["code"] = field["code"][:-1]

                if not field.get("type"):
                    print("ERROR !!!!!!!!!!!!", field)
                    field["type"] = "string"
                if field["code"].startswith("DT_"):
                    types = [
                        AttrType(
                            qname="{http://www.w3.org/2001/XMLSchema}date", native=True
                        )
                    ]
                elif (
                    field["type"] == "int"
                    or field["type"] == "float"
                    and int(field["decimal"]) == 0
                ):
                    types = [
                        AttrType(
                            qname="{http://www.w3.org/2001/XMLSchema}integer",
                            native=True,
                        )
                    ]
                elif field["type"] == "float":
                    digits = int(field["decimal"])
                    if digits < 10:
                        tdec = f"TDec_160{digits}"
                    else:
                        tdec = f"TDec_16{digits}"
                    types = [
                        AttrType(
                            qname="{http://www.w3.org/2001/XMLSchema}float", native=True
                        )
                    ]
                else:
                    types = [
                        AttrType(
                            qname="{http://www.w3.org/2001/XMLSchema}string",
                            native=True,
                        )
                    ]
                # TODO diff entrada/saida e O / OC (Obrigatorio Condicional); see ICMS C170
                restrictions = Restrictions(
                    min_occurs=field.get("required")
                    and 1
                    or 0  # TODO if required 'OC' -> no
                )
                attr = Attr(
                    tag=field["code"],
                    name=field["code"],
                    types=types,
                    restrictions=restrictions,
                    help=field["desc"],
                    index=field["index"],
                    default=tdec,
                )
                attrs.append(attr)
                # TODO add date_field and company_id if level == 1, or via mixin?

            for child in register["children_m2o"]:
                child_qname = "Registro{}".format(child["code"])
                types = [AttrType(qname=child_qname, native=False)]
                m2o_field_name = "reg_{}_id".format(child["code"])
                attr = Attr(
                    tag=m2o_field_name,
                    name=m2o_field_name,
                    types=types,
                    help=child["desc"],
                )
                attrs.append(attr)

            if register.get("parent"):
                parent = register["parent"]
                parent_qname = "Registro{}".format(parent["code"])
                types = [AttrType(qname=parent_qname, native=False)]
                m2o_field_name = "reg_{}_ids_{}_id".format(
                    register["code"], parent_qname
                )
                attr = Attr(
                    tag=m2o_field_name,
                    name=m2o_field_name,
                    types=types,
                    help=parent["desc"],
                )
                attrs.append(attr)

            for child in register["children_o2m"]:
                child_qname = "Registro{}".format(child["code"])
                types = [AttrType(qname=child_qname, native=False)]
                restrictions = Restrictions(
                    max_occurs=999999
                )  # TODO make it work. It uses metadata in generate.py and fail

                m2o_field_name = "reg_{}_ids".format(child["code"])
                attr = Attr(
                    tag=m2o_field_name,
                    name=m2o_field_name,
                    types=types,
                    restrictions=restrictions,
                    help=child["desc"],
                )
                attrs.append(attr)

            # TODO patch ECD Registro0035
            k = Class(
                qname=name,
                tag=name,
                location="TODO",
                attrs=attrs,
                help=register["desc"],
                module=mod,
            )
            classes.append(k)
            generator.filters.all_complex_types.append(k)
        structure = get_structure(mod, registers)
        source = (
            HEADER
            + f'\n"""\n{structure}\n"""\n\n'
            + IMPORTS
            + "\n"
            + generator.render_classes(classes, None)
        )
        try:
            source = format_str(source, mode=FileMode())
        except Exception as e:
            print(e)
        path = Path(str(SPECS_PATH) + f"/{year}/{mod}/sped_{mod}.py")
        print("written file", path)
        path.write_text(source, encoding="utf-8")


if __name__ == "__main__":
    main()
